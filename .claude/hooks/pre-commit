#!/bin/bash
# Pre-commit hook to enforce project standards
# This hook runs before every commit to ensure compliance

set -e

PROJECT_ROOT="$(git rev-parse --show-toplevel)"
FAILED=0

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "üîç Running pre-commit checks..."
echo ""

# ============================================================================
# 1. Check file naming conventions (snake_case)
# ============================================================================
echo "üìã Checking file naming conventions..."

# Get all staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Skip files that are binary or in certain directories
SKIP_PATTERNS=(
    "^\.git/"
    "^node_modules/"
    "\.pyc$"
    "__pycache__"
    "\.egg-info/"
    "\.pytest_cache"
)

check_naming() {
    local file="$1"
    local basename=$(basename "$file")
    local dirname=$(dirname "$file")

    # Skip certain patterns
    for pattern in "${SKIP_PATTERNS[@]}"; do
        if [[ $file =~ $pattern ]]; then
            return 0
        fi
    done

    # Skip certain directories that can have different conventions
    if [[ $dirname =~ ^\.git ]] || [[ $dirname =~ __pycache__ ]]; then
        return 0
    fi

    # Check file extensions that should follow snake_case
    if [[ $basename =~ \.(py|md|txt|yml|yaml|json|sh)$ ]]; then
        # snake_case: lowercase with underscores and hyphens
        if [[ ! $basename =~ ^[a-z0-9_-]+\.[a-z0-9]+$ ]]; then
            echo -e "${RED}‚ùå FAILED${NC}: $file"
            echo "   Reason: File should use snake_case or kebab-case naming"
            echo "   Example: 'agent-handoff-protocol.md' (NOT 'AGENT-HANDOFF-PROTOCOL.md')"
            return 1
        fi
    fi

    return 0
}

for file in $STAGED_FILES; do
    if ! check_naming "$file"; then
        FAILED=1
    fi
done

if [ $FAILED -eq 0 ]; then
    echo -e "${GREEN}‚úÖ PASSED${NC}: All file names follow conventions"
else
    echo ""
    echo -e "${RED}‚ùå FILE NAMING CHECK FAILED${NC}"
    echo "Please rename files to follow snake_case/kebab-case convention."
    echo "Examples:"
    echo "  ‚ùå WRONG: AGENT-HANDOFF-PROTOCOL.md"
    echo "  ‚úÖ RIGHT: agent-handoff-protocol.md"
    echo ""
    exit 1
fi

echo ""

# ============================================================================
# 2. Check for hardcoded secrets and credentials
# ============================================================================
echo "üîê Checking for hardcoded secrets..."

SECRETS_FOUND=0

for file in $STAGED_FILES; do
    # Skip binary files and certain directories
    if file "$file" 2>/dev/null | grep -q "binary"; then
        continue
    fi

    # Skip test and documentation files
    if [[ $file =~ (test_|example|sample|\.md|\.txt|\.sh) ]]; then
        continue
    fi

    # Check for common secret patterns (only in source code)
    if grep -Ei "password|api.key|secret|token|private.key" "$file" 2>/dev/null | grep -v "#"; then
        echo -e "${RED}‚ùå FAILED${NC}: $file"
        echo "   Reason: Possible hardcoded credentials detected"
        SECRETS_FOUND=1
    fi
done

if [ $SECRETS_FOUND -eq 0 ]; then
    echo -e "${GREEN}‚úÖ PASSED${NC}: No obvious hardcoded secrets found"
else
    echo ""
    echo -e "${RED}‚ùå SECURITY CHECK FAILED${NC}"
    exit 1
fi

echo ""

# ============================================================================
# 3. Check Python code style (basic checks)
# ============================================================================
echo "üêç Checking Python code style..."

PYTHON_FILES=$(echo "$STAGED_FILES" | grep '\.py$')

if [ ! -z "$PYTHON_FILES" ]; then
    # Check if black is available
    if command -v black &> /dev/null; then
        echo "   Running black format check..."
        if ! black --check $PYTHON_FILES 2>/dev/null; then
            echo -e "${YELLOW}‚ö†Ô∏è  WARNING${NC}: Code not formatted with black"
            echo "   Run: black $PYTHON_FILES"
        fi
    fi

    # Check if flake8 is available
    if command -v flake8 &> /dev/null; then
        echo "   Running flake8 style check..."
        if ! flake8 $PYTHON_FILES 2>/dev/null; then
            echo -e "${RED}‚ùå FAILED${NC}: Code style issues found"
            exit 1
        fi
    fi

    echo -e "${GREEN}‚úÖ PASSED${NC}: Python code style checks passed"
else
    echo "   (No Python files in commit)"
fi

echo ""

# ============================================================================
# 4. Check commit message format (Conventional Commits)
# ============================================================================
echo "üìù Checking commit message format..."

# This will be checked in prepare-commit-msg hook
# But we can do a basic check here
if [ -f "$PROJECT_ROOT/.gitmessage" ]; then
    echo -e "${GREEN}‚úÖ PASSED${NC}: Commit message template configured"
else
    echo -e "${YELLOW}‚ö†Ô∏è  WARNING${NC}: No .gitmessage template found"
fi

echo ""

# ============================================================================
# 5. Run tests if they exist
# ============================================================================
echo "üß™ Checking tests..."

if [ -f "$PROJECT_ROOT/pytest.ini" ] || [ -d "$PROJECT_ROOT/tests" ]; then
    if command -v pytest &> /dev/null; then
        echo "   Running pytest..."

        # Only check if test files are being modified
        TEST_FILES=$(echo "$STAGED_FILES" | grep -E "^tests/" || echo "")

        if [ ! -z "$TEST_FILES" ]; then
            if ! pytest tests/ -q 2>/dev/null; then
                echo -e "${RED}‚ùå FAILED${NC}: Tests did not pass"
                exit 1
            fi
            echo -e "${GREEN}‚úÖ PASSED${NC}: All tests passed"
        else
            echo "   (No test files in commit)"
        fi
    fi
else
    echo "   (No tests directory found)"
fi

echo ""

# ============================================================================
# Summary
# ============================================================================
echo "="
echo -e "${GREEN}‚úÖ ALL PRE-COMMIT CHECKS PASSED${NC}"
echo "="
echo ""

exit 0
